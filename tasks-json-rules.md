# Структура JSON и правила заполнения (v2)

## Назначение
Документ описывает актуальный формат данных заданий для приложения.

Ключевые изменения:
- поддержка нескольких предметов;
- поддержка нескольких типов заданий;
- единый формат поля `hint` без `hintFormat`;
- `id` нигде не используется.

## Структура каталогов
Данные заданий хранятся по предметам:

```text
data/
  subjects/
    index.json
    russian/
      index.json
      dictionaries/
        *.json
    english/
      index.json
      dictionaries/
        *.json
```

## Предметы
Файл: `data/subjects/index.json`

```json
[
  { "title": "Русский язык", "dir": "russian" },
  { "title": "Английский язык", "dir": "english" }
]
```

Правила:
1. `title` — непустая строка.
2. `dir` — непустая строка, имя каталога предмета в `data/subjects/`.
3. `dir` должен быть уникальным.

## Словари предмета
Файл: `data/subjects/<dir>/index.json`

```json
[
  { "title": "Орфография 2 класс", "file": "spelling-main.json" },
  { "title": "Словарные слова", "file": "dictionary-words.json" }
]
```

Правила:
1. `title` — непустая строка.
2. `file` — непустая строка, имя файла словаря в `data/subjects/<dir>/dictionaries/`.
3. `file` должен быть уникальным в рамках предмета.

## Формат файла словаря
Файл: `data/subjects/<dir>/dictionaries/<file>`

```json
{
  "title": "Название словаря",
  "description": "Опционально",
  "tasks": [
    {
      "type": "insertMissingLetters",
      "word": "м[ао|о]л[ао|о]ко",
      "hint": "Проверка: **молоко`** — __моло`чный__."
    }
  ]
}
```

Правила:
1. `title` — непустая строка.
2. `description` — опциональная строка.
3. `tasks` — непустой массив заданий.

## Общие поля задания
Для любого задания:
1. `type` — обязательный тип задания.
2. `hint` — обязательная непустая строка.
3. `prompt` — опциональная строка (текст инструкции в интерфейсе). Если отсутствует или пустая, не отображается и не занимает место.

## Формат `hint`
`hint` поддерживает встроенный легкий формат для выделения частей текста:

### Маркеры форматирования

| Маркер | Название | Результат | Пример |
|--------|----------|-----------|--------|
| `**текст**` | Жирный | Жирный шрифт | `**молоко**` → **молоко** |
| `!!текст!!` | Красный цвет | Красный цвет текста | `!!о!!` → о (красным) |
| `__текст__` | Подчёркивание | Подчёркнуто красной линией | `__молочный__` → <u>молочный</u> |
| `!!__текст__!!` | Комбо | Красный + подчёркнутый | `!!__о__!!` → о (красное подчёркнутое) |
| `__!!текст!!__` | Комбо (альт.) | Красный + подчёркнутый | `__!!о!!__` → о (красное подчёркнутое) |
| `` ` `` | Ударение | Ударение после гласной | `молоко`` → молоко́ |
| `\n` | Перенос строки | Новая строка | `Строка 1\nСтрока 2` |

### Правила использования

1. **Порядок обработки маркеров**: комбинированные (`!!__...__!!`, `__!!...!!__`) → одиночные (`!!...!!`, `__...__`) → существующие (`**...**`, `` ` ``)
2. **Вложенность**: можно комбинировать маркеры, например `__моло!!о!!чный__` — подчёркнутое слово с красной буквой внутри
3. **Цвет текста**: основной текст hint отображается чёрным, только маркер `!!` меняет цвет на красный
4. **Подчёркивание**: только маркер `__` добавляет подчёркивание красного цвета

### Примеры

```json
// Выделение ошибочной буквы красным
{
  "hint": "В слове пропущена буква !!о!!."
}
// Результат: В слове пропущена буква о (красным).

// Подчёркнутое проверочное слово
{
  "hint": "Проверочное слово: __молочный__."
}
// Результат: Проверочное слово: <u>молочный</u> (красная линия).

// Комбинированный стиль
{
  "hint": "Буква !!__о__!! пропущена."
}
// Результат: Буква о (красное + подчёркнутое) пропущена.

// Сложное форматирование с вложенностью
{
  "hint": "Проверка: !!__моло__!!ко`. Проверочное слово: __моло!!о!!чный__."
}
// Результат: Проверка: <span style="color:red;text-decoration:underline">моло</span>ко́.
//           Проверочное слово: <u>моло<span style="color:red">о</span>чный</u>.

// Смешивание с жирным и ударением
{
  "hint": "**Слово**: молоко` — проверочное: __молочный__."
}
// Результат: <strong>Слово</strong>: молоко́ — проверочное: <u>молочный</u>.
```

### Важно

1. `hintFormat` не используется.
2. Произвольный HTML в `hint` не используется.
3. Подчёркивание всегда красного цвета (согласно CSS `var(--error)`).
4. Основной текст hint (без маркеров) отображается чёрным цветом.

## Типы заданий

### 1. `insertMissingLetters`
Текущий тип с орфограммами в слове.

Пример:
```json
{
  "type": "insertMissingLetters",
  "word": "м[ао|о]л[ао|о]ко",
  "hint": "Проверка: **молоко`** — __моло`чный__."
}
```

Правила валидации:
1. `word` — непустая строка.
2. В `word` минимум один токен `[варианты|правильная]`.
3. Каждый токен строго в формате `[варианты|правильная]`.
4. `варианты` — 2-4 буквы.
5. `правильная` — ровно 1 буква и входит в `варианты`.

### 2. `chooseWordVariant`
Выбор правильного слова из нескольких вариантов.

Пример:
```json
{
  "type": "chooseWordVariant",
  "prompt": "Выбери правильное написание",
  "questionDisplay": "Стол",
  "questionAnswer": "Стол → Table",
  "variants": ["малако", "молако", "малоко", "молоко"],
  "correctIndex": 3,
  "hint": "Проверка: **молоко`** — __моло`чный__."
}
```

Правила валидации:
1. `variants` — массив длиной 2-6.
2. Все элементы `variants` — непустые уникальные строки.
3. `correctIndex` — целое число в диапазоне `0..variants.length-1`.
4. `questionDisplay` — опциональная строка (отображается крупно по центру на странице вопроса).
5. `questionAnswer` — опциональная строка (заменяет `questionDisplay` после ответа; если не указан, используется `questionDisplay`).

Поведение:
1. Варианты перемешиваются при каждом показе задания.
2. `correctIndex` всегда указывает на индекс в исходном массиве `variants`.
3. `questionDisplay` показывается во время выбора ответа.
4. После ответа `questionDisplay` заменяется на `questionAnswer` (если указан).

### 3. `buildForeignWord`
Сборка иностранного слова из букв по русскому слову.

Пример:
```json
{
  "type": "buildForeignWord",
  "prompt": "Собери слово на английском",
  "sourceWord": "стол",
  "targetWord": "table",
  "letters": ["t", "a", "b", "l", "e", "d", "p"],
  "hint": "**table** — это __стол__."
}
```

Правила валидации:
1. `sourceWord` — непустая строка.
2. `targetWord` — непустая строка.
3. `letters` — массив строк длины 1.
4. `letters` содержит все буквы `targetWord` с нужной кратностью.
5. Лишние буквы в `letters` разрешены.
6. Дубли в `letters` разрешены.
7. Каждая буква из `letters` может использоваться пользователем только 1 раз.

### 4. `pairMatch`
Сопоставление пар (например, слово и перевод).

Пример:
```json
{
  "type": "pairMatch",
  "prompt": "Сопоставь пары",
  "pairs": [
    ["стол", "table"],
    ["книга", "book"],
    ["собака", "dog"]
  ],
  "hint": "Сверь перевод каждого слова."
}
```

Правила валидации:
1. `pairs` — массив длиной 2-8.
2. Каждый элемент `pairs` — массив из 2 непустых строк.
3. Левые значения уникальны.
4. Правые значения уникальны.

Поведение:
1. В данных пары хранятся сразу как строки.
2. В интерфейсе левая и правая колонки перемешиваются при показе задания.

### 5. `audioToWord`
Задание с аудио. Поддерживается 2 режима.

#### 5.1 `mode: "chooseVariant"`

```json
{
  "type": "audioToWord",
  "mode": "chooseVariant",
  "prompt": "Прослушай и выбери слово",
  "audioSrc": "audio/en/table.mp3",
  "variants": ["table", "cable", "stable", "tablet"],
  "correctIndex": 0,
  "hint": "Правильный ответ: **table**."
}
```

Правила:
1. `audioSrc` — непустая строка (путь к аудио-файлу).
2. `variants` и `correctIndex` валидируются так же, как в `chooseWordVariant`.

#### 5.2 `mode: "buildWord"`

```json
{
  "type": "audioToWord",
  "mode": "buildWord",
  "prompt": "Прослушай и собери слово",
  "audioSrc": "audio/en/table.mp3",
  "targetWord": "table",
  "letters": ["t", "a", "b", "l", "e", "d", "p"],
  "hint": "Правильный ответ: **table**."
}
```

Правила:
1. `audioSrc` — непустая строка.
2. `targetWord` и `letters` валидируются так же, как в `buildForeignWord`.

## Итоговый список допустимых `type`
- `insertMissingLetters`
- `chooseWordVariant`
- `buildForeignWord`
- `pairMatch`
- `audioToWord`

## Итоговый список допустимых `audioToWord.mode`
- `chooseVariant`
- `buildWord`
